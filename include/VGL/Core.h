#pragma once

#include <cstdint>
#include <vulkan/vulkan.h>

#pragma region Version Macros

/*
* A bunch of these are basically just VGL wrappers for the Vulkan ones.
* One noteable change is that the Vulkan API version macros are used as the older ones are deprecated
*/

#define VGL_MAKE_API_VERSION(variant, major, minor, patch)	VK_MAKE_API_VERSION(variant, major, minor, patch)
#define VGL_MAKE_VERSION(major, minor, patch)				VGL_MAKE_API_VERSION(0, major, minor, patch)

#define VGL_API_VERSION_1_0				VGL_MAKE_API_VERSION(0, 1, 0, 0)
#define VGL_VERSION_1_0					VGL_MAKE_API_VERSION(0, 1, 0, 0)

#define VGL_VERSION_VARIANT(version)	VK_API_VERSION_VARIANT(version)
#define VGL_VERSION_MAJOR(version)		VK_API_VERSION_MAJOR(version)
#define VGL_VERSION_MINOR(version)		VK_API_VERSION_MINOR(version)
#define VGL_VERSION_PATCH(version)		VK_API_VERSION_PATCH(version)

#define VGL_VULKAN_HEADER_VERSION		VK_HEADER_VERSION
#define VGL_VULKAN_VERSION				VK_HEADER_VERSION_COMPLETE

namespace VGL
{
	typedef uint32_t VGLVersion;
}

#pragma endregion

#pragma region Error

/*
* Taken from Vulkan but will be modified for extra errors related to VGL functions
*/

namespace VGL
{
    typedef enum VGLResult {
        VGL_RESULT_SUCCESS = 0,
        VGL_RESULT_NOT_READY = 1,
        VGL_RESULT_TIMEOUT = 2,
        VGL_RESULT_EVENT_SET = 3,
        VGL_RESULT_EVENT_RESET = 4,
        VGL_RESULT_INCOMPLETE = 5,

        VGL_ERROR_OUT_OF_HOST_MEMORY = -1,
        VGL_ERROR_OUT_OF_DEVICE_MEMORY = -2,
        VGL_ERROR_INITIALIZATION_FAILED = -3,
        VGL_ERROR_DEVICE_LOST = -4,
        VGL_ERROR_MEMORY_MAP_FAILED = -5,
        VGL_ERROR_LAYER_NOT_PRESENT = -6,
        VGL_ERROR_EXTENSION_NOT_PRESENT = -7,
        VGL_ERROR_FEATURE_NOT_PRESENT = -8,
        VGL_ERROR_INCOMPATIBLE_DRIVER = -9,
        VGL_ERROR_TOO_MANY_OBJECTS = -10,
        VGL_ERROR_FORMAT_NOT_SUPPORTED = -11,
        VGL_ERROR_FRAGMENTED_POOL = -12,
        VGL_ERROR_UNKNOWN = -13,

        VGL_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
        VGL_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
        VGL_ERROR_FRAGMENTATION = -1000161000,
        VGL_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
        VGL_PIPELINE_COMPILE_REQUIRED = 1000297000,
        VGL_ERROR_SURFACE_LOST_KHR = -1000000000,
        VGL_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
        VGL_SUBOPTIMAL_KHR = 1000001003,
        VGL_ERROR_OUT_OF_DATE_KHR = -1000001004,
        VGL_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
        VGL_ERROR_VALIDATION_FAILED_EXT = -1000011001,
        VGL_ERROR_INVALID_SHADER_NV = -1000012000,
        VGL_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
        VGL_ERROR_NOT_PERMITTED_KHR = -1000174001,
        VGL_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
        VGL_THREAD_IDLE_KHR = 1000268000,
        VGL_THREAD_DONE_KHR = 1000268001,
        VGL_OPERATION_DEFERRED_KHR = 1000268002,
        VGL_OPERATION_NOT_DEFERRED_KHR = 1000268003,
        VGL_ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000,
        VGL_ERROR_OUT_OF_POOL_MEMORY_KHR = VK_ERROR_OUT_OF_POOL_MEMORY,
        VGL_ERROR_INVALID_EXTERNAL_HANDLE_KHR = VK_ERROR_INVALID_EXTERNAL_HANDLE,
        VGL_ERROR_FRAGMENTATION_EXT = VK_ERROR_FRAGMENTATION,
        VGL_ERROR_NOT_PERMITTED_EXT = VK_ERROR_NOT_PERMITTED_KHR,
        VGL_ERROR_INVALID_DEVICE_ADDRESS_EXT = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
        VGL_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
        VGL_PIPELINE_COMPILE_REQUIRED_EXT = VK_PIPELINE_COMPILE_REQUIRED,
        VGL_ERROR_PIPELINE_COMPILE_REQUIRED_EXT = VK_PIPELINE_COMPILE_REQUIRED,
        VGL_RESULT_MAX_ENUM = 0x7FFFFFFF
    } Result;
}

#define vglToVGLResult(vkResult) static_cast<VGL::VGLResult>(vkResult)

#pragma endregion